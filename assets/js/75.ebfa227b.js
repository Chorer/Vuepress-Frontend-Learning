(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{616:function(t,v,s){"use strict";s.r(v);var _=s(12),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("HTTP 是明文传输的，而 HTTPS 是加密传输的，要更加安全。HTTP/1.1 不支持 HTTPS，而 HTTP/2 为了向下兼容，不强制使用 HTTPS，可以选择开启或者不开启。")]),t._v(" "),s("h2",{attrs:{id:"https-安全性的基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-安全性的基础"}},[t._v("#")]),t._v(" HTTPS 安全性的基础")]),t._v(" "),s("p",[t._v("HTTPS 的安全性，体现在机密性、完整性和身份验证。")]),t._v(" "),s("h3",{attrs:{id:"机密性-对称加密-非对称加密-混合加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#机密性-对称加密-非对称加密-混合加密"}},[t._v("#")]),t._v(" 机密性 —— 对称加密/非对称加密/混合加密")]),t._v(" "),s("p",[t._v("为了确保信息传输的安全，必须使用加密算法对信息进行加密。加密和解密都需要依靠密钥，因此问题的关键就在于如何在一开始安全地传递密钥，也就是所谓的“密钥交换”。")]),t._v(" "),s("p",[s("strong",[t._v("对称加密：")])]),t._v(" "),s("p",[t._v("只有一把私钥。服务端发送给客户端一把专属于它的私钥，以后双方都用这把私钥进行加密和解密。")]),t._v(" "),s("p",[t._v("对称加密存在两个问题：")]),t._v(" "),s("ul",[s("li",[t._v("不同客户端，私钥就不同，因此服务端这边需要维护大量私钥")]),t._v(" "),s("li",[t._v("无法保证在最开始安全地发送私钥给客户端，因为它是明文传输的，一旦被黑客拦截，黑客就可以随时用私钥解密信息")])]),t._v(" "),s("p",[s("strong",[t._v("非对称加密：")])]),t._v(" "),s("p",[t._v("用公钥加密，用私钥解密。服务端首先生成一对公钥和私钥，私钥自己保存，公钥发送给客户端，客户端每次都通过公钥对信息进行加密，然后把信息发给服务端，服务端再使用私钥进行解密。即使黑客截获了公钥，意义也不大，因为信息必须依靠私钥才能解密。反过来，如果服务端要发送信息给客户端，那么客户端这边也需要生成一对公私钥，从而实现双向的加密通信。")]),t._v(" "),s("p",[t._v("但非对称加密也存在一个问题：每次加密和解密耗时过长，这会拖慢双方的通信速度")]),t._v(" "),s("p",[s("strong",[t._v("混合加密：")])]),t._v(" "),s("p",[t._v("混合加密同时结合了对称加密和非对称加密：")]),t._v(" "),s("ul",[s("li",[t._v("服务端这边基于==非对称加密算法==生成一对公钥和私钥，然后把公钥传给客户端")]),t._v(" "),s("li",[t._v("客户端这边基于==对称加密算法==生成一个后续通信使用的会话密钥（session key），用会话密钥加密要发送的信息，用公钥加密会话密钥本身，也就是说，客户端发给服务端的有两个东西：\n"),s("ul",[s("li",[t._v("用公钥加密的会话密钥")]),t._v(" "),s("li",[t._v("用会话密钥加密的信息")])])]),t._v(" "),s("li",[t._v("服务端拿到后，首先用私钥解密，拿到会话密钥，然后再用会话密钥解密，拿到实际的信息。")])]),t._v(" "),s("p",[t._v("在这之后，实际上已经解决了安全传递密钥（会话密钥）的问题。之后的每次通信中，双端只需要用同样的会话密钥加密和解密即可，这样就确保了安全 + 性能。")]),t._v(" "),s("p",[t._v("但混合加密也存在一个问题：缺乏身份验证。一开始服务端返回的公钥其实也是明文传输的，如果黑客进行了拦截，那么就可以发起中间人攻击，冒充客户端或者服务端，去劫持和篡改数据，因此数据的完整性也就无法保证了。")]),t._v(" "),s("h3",{attrs:{id:"身份验证和完整性-数字签名、数字证书、证书链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#身份验证和完整性-数字签名、数字证书、证书链"}},[t._v("#")]),t._v(" 身份验证和完整性 —— 数字签名、数字证书、证书链")]),t._v(" "),s("p",[t._v("混合加密缺乏身份验证，因此容易导致中间人攻击，使数据完整性出现问题。接下来讲讲如何保证身份验证和数据完整性。")]),t._v(" "),s("h4",{attrs:{id:"数字签名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数字签名"}},[t._v("#")]),t._v(" 数字签名")]),t._v(" "),s("p",[t._v("数字签名和非对称加密是反过来的，用私钥进行加密，而用公钥进行解密。服务端这边基于摘要算法，对要传输的数据进行 hash 计算，从而得到一个与数据对应的摘要（digest），然后用私钥对摘要进行加密，形成签名，接着把 签名+数据 发送给客户端。客户端收到签名和数据后：")]),t._v(" "),s("ul",[s("li",[t._v("保证身份验证：首先，用此前拿到的公钥进行验签（解密签名），拿到摘要。公钥和私钥是一对的，客户端认为，既然自己可以用服务端当时发过来的公钥对此时收到的签名进行解密，那么就可以确保这个签名确实是服务端自己加密然后发送过来的，身份验证这一关就 ok 了；")]),t._v(" "),s("li",[t._v("保证数据完整性：接着，客户端对数据进行同样的 hash 计算，得到另一个摘要，将这个摘要与签名中的摘要进行对比，如果一致，说明数据是完整没有被篡改的 —— 因为如果被篡改（哪怕只是细微的变动），那么客户端基于被篡改的数据进行 hash 得到的摘要会和签名中的摘要完全不同。")])]),t._v(" "),s("h4",{attrs:{id:"数字证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[t._v("#")]),t._v(" 数字证书")]),t._v(" "),s("p",[t._v("但是这一切建立在一个大前提下，也是我们最最核心的问题 —— 保证==客户端持有的公钥确实是服务端的公钥==。要知道，服务端最开始分发这个公钥给客户端的时候，可能被黑客拦截了，然后黑客再掉包成自己的公钥发给客户端，客户端不知道，可能自己一直在和黑客而不是服务端通信，毕竟它坚信自己确实收到了服务端的公钥，且自己持有的公钥可以解密对方用私钥加密的东西，因此不会产生怀疑。")]),t._v(" "),s("p",[t._v("为了解决这种情况，我们需要找一个受信任的第三方机构（认证机构 CA）参与其中，通过它（而不是服务端）来进行服务端公钥的分发，从而确保客户端得到的公钥确实是来自于服务端的。")]),t._v(" "),s("p",[t._v("具体地说，服务端首先向 CA 提交相关信息，申请一个证书，证书的内容是：")]),t._v(" "),s("ul",[s("li",[t._v("基本信息：CA 信息、服务端信息、服务端公钥、有效期等")]),t._v(" "),s("li",[t._v("签名：针对上述信息生成一个摘要，用 CA 的私钥去加密这个摘要，得到一个签名。")])]),t._v(" "),s("p",[t._v("现在，这个证书就是被签过名的了。CA 把生成的证书给服务端，服务端再把证书传给客户端。客户端做两件事：")]),t._v(" "),s("ul",[s("li",[t._v("通过内置的 CA 公钥进行解密，如果可以解开，说明证书来源是安全可信的。这里解决了身份验证问题。")]),t._v(" "),s("li",[t._v("对基本信息进行哈希计算得到摘要值，将其与解密得到的摘要值进行比对，如果一致，说明信息没有被篡改。这里解决了完整性问题。")])]),t._v(" "),s("p",[t._v("自此，已经解决了“确保客户端持有的公钥确实是服务端的公钥”的问题，之后的流程就和前面说的一样了。")]),t._v(" "),s("blockquote",[s("p",[t._v("上面说了，服务端需要把证书发送给客户端，那么黑客是否可能在这个过程中对证书做手脚呢？")])]),t._v(" "),s("ul",[s("li",[t._v("比如说，黑客可能会篡改证书的基本信息？不可能，只要篡改了基本信息，后续客户端进行摘要值对比的时候，就会发现两者是不一致的，因此就会认定这个证书以及它携带的公钥是有问题的。")]),t._v(" "),s("li",[t._v("那么，黑客是否可以先篡改证书的基本信息，然后再生成对应的摘要，再去加密这个摘要形成签名呢？这样两个摘要值的比对结果一定是一致的了。然而这个也是不可能的，因为黑客没有 CA 的私钥，无法自己形成签名。")])]),t._v(" "),s("h4",{attrs:{id:"证书链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#证书链"}},[t._v("#")]),t._v(" 证书链")]),t._v(" "),s("p",[t._v("前面说了，客户端是通过内置的 CA 公钥验签的，那么如何保证这个公钥确实是来自于 CA 而不是黑客呢？似乎我们又绕回到了最初的问题。")]),t._v(" "),s("p",[t._v("事实就是，会有另一个证书保证这个 CA 公钥的可靠性。以此类推，层层向上，最终形成一条证书链。证书链的顶端是根证书，它是自签名的，也就是自己证明自己，而我们也需要无条件信任它。")]),t._v(" "),s("p",[t._v("操作系统或者浏览器会内置各大 CA 的根证书，客户端验签的时候，首先会用根证书的根公钥解密根证书，得到一级证书公钥，接着用一级证书公钥解密一级证书，得到二级证书公钥......以此类推，最终拿到当前证书（服务端发送过来的证书）的公钥，再用公钥对其进行解密和验证。")]),t._v(" "),s("h2",{attrs:{id:"https-安全性的实现-tls-连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-安全性的实现-tls-连接"}},[t._v("#")]),t._v(" HTTPS 安全性的实现 —— TLS 连接")]),t._v(" "),s("h3",{attrs:{id:"tls-1-2-四次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-2-四次握手"}},[t._v("#")]),t._v(" TLS 1.2 四次握手")]),t._v(" "),s("p",[t._v("HTTPS 的安全性是通过 SSL/TLS 实现的 —— https = http over SSL/TLS，即在原先的应用层和传输层中间再加一个 TLS 层。除了之前的 TCP 三次握手之外，客户端还需要和服务端通过四次握手建立 TLS 连接。")]),t._v(" "),s("p",[t._v("首先还是通过三次握手建立 TCP 连接：")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/7.png"}}),t._v(" "),s("p",[t._v("接着通过四次握手建立 TLS 连接：")]),t._v(" "),s("ol",[s("li",[t._v("客户端发送 client hello 消息，主要内容是：")])]),t._v(" "),s("ul",[s("li",[t._v("自己支持的 TLS 协议版本（version）")]),t._v(" "),s("li",[t._v("支持的密码套件列表（cipher suites）")]),t._v(" "),s("li",[t._v("一个随机数（client random）")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("服务端收到 client hello 消息后：")])]),t._v(" "),s("ul",[s("li",[t._v("发送 server hello 消息进行回应，主要内容是：\n"),s("ul",[s("li",[t._v("自己和客户端协商好的 TLS 协议版本（version）")]),t._v(" "),s("li",[t._v("自己从密码套件列表中选用的一个密码套件（cipher suite）")]),t._v(" "),s("li",[t._v("一个随机数（server random）")])])]),t._v(" "),s("li",[t._v("发送 server certificate 消息，传递服务端证书")]),t._v(" "),s("li",[t._v("发送 server key exchange 消息，传递密钥交换算法的参数（server params）")]),t._v(" "),s("li",[t._v("发送 server hello done 消息，表示 server hello 完成")])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/8.png"}}),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("客户端验证证书，确认服务端身份无误后：")])]),t._v(" "),s("ul",[s("li",[t._v("发送 client key exchange，传递密钥交换算法的参数（client params）")]),t._v(" "),s("li",[t._v("客户端和服务端拿着共有的 client params 和 server params，利用 ECDHE 算法计算出 预备主密钥（pre-master secret）")]),t._v(" "),s("li",[t._v("客户端和服务端拿着共有的 client random、server random、pre-master secret，生成主密钥（master secret）。（这里使用了三个随机数，是为了在两端可能不可靠的情况下提高随机程度）")]),t._v(" "),s("li",[t._v("主密钥派生出会话密钥")]),t._v(" "),s("li",[t._v("客户端发送 change cipher spec 消息，通知服务端用会话密钥来加密双方通信")]),t._v(" "),s("li",[t._v("客户端发送 finished，结束自己的握手")])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/9.png"}}),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("服务端收到消息后：")])]),t._v(" "),s("ul",[s("li",[t._v("发送 change sipher spec，表示同意用会话密钥加密双方的通信")]),t._v(" "),s("li",[t._v("发送 finished，表示结束自己的握手")])]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/10.png"}}),t._v(" "),s("p",[t._v("这样，TLS 四次握手就结束了，此后双方收发加密的 https 请求和响应。")]),t._v(" "),s("p",[t._v("PS：在最开始，服务端挑选了一个密码套件，密码套件里面会包含一个密钥交换算法。本例子中选择的是 ECDHE 算法。它与 RSA 算法有两个不同点：")]),t._v(" "),s("ul",[s("li",[t._v("使用 ECDHE，双端需要互换密钥交换算法的参数，利用两个参数生成 pre-master secret；使用 RSA，只需要由客户端这边直接生成 pre-master secret，用公钥加密后发送给服务端。当然，最终都需要使用 pre-master secret + client random + server random 生成 master secret，这点是一样的")]),t._v(" "),s("li",[t._v("使用 ECDHE，可以实现 TLS False Start，即抢跑，客户端可以在服务端尚未响应 finished 的时候就开始发送 https 请求；使用 RSA，只能在双方都 finished 之后才能收发请求响应。")])]),t._v(" "),s("h3",{attrs:{id:"tls-1-3-三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-3-三次握手"}},[t._v("#")]),t._v(" TLS 1.3 三次握手")]),t._v(" "),s("p",[t._v("TLS 1.3 中，客户端一开始发送 client hello 消息的时候，就携带上了密钥交换算法的参数（client params），而不是像 TLS 1.2 那样在第二次发送消息的时候再携带，因此 1.3 只需要三次握手，1次往返（1-rtt）；而 1.2 需要四次握手，2次往返（2-rtt）")]),t._v(" "),s("h2",{attrs:{id:"https-的性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-的性能优化"}},[t._v("#")]),t._v(" HTTPS 的性能优化")]),t._v(" "),s("p",[t._v("相比 http，https 需要通过握手创建 tls 连接，最多需要消耗两个 rtt，因此 https 一般会比 http 慢。如何优化 https 的连接速度呢？可以从以下几个方面入手：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("硬件优化：更快更好的 CPU，加速握手和传输SSL 加速卡，加速加解密")])]),t._v(" "),s("li",[s("p",[t._v("软件优化：Linux 内核版本升级，Nginx 版本升级，OpenSSL 版本升级等")])]),t._v(" "),s("li",[s("p",[t._v("协议优化：使用 TLS 1.3，大幅度简化握手过程，只需要 1-rtt使用 ECDHE 作为密钥交换算法，支持 TLS False Start 抢跑")])]),t._v(" "),s("li",[s("p",[t._v("证书优化：")]),t._v(" "),s("ul",[s("li",[t._v("使用 ECDSA 证书优化传输过程，使用 OCSP 优化证书验证")])])]),t._v(" "),s("li",[s("p",[t._v("会话复用：")]),t._v(" "),s("p",[t._v("TLS 连接的重点在于创建共有的主密钥（或者说会话密钥）。若是每次创建 TLS 连接都需要重新创建主密钥，未免太大费周章了 —— 假如这个主密钥可以缓存下来，那么以后同一个客户端和服务端再次连接的时候就可以直接拿来继续使用了。这就是会话复用，而实现会话复用有 session id 和 session ticket 两种方式。")]),t._v(" "),s("ul",[s("li",[t._v("==session id==：客户端和服务端首次握手成功后，双方会缓存一个 key-value，key 是 此次会话独有的 session-id，value 是会话密钥。下次同一个客户端再和服务端创建 TLS 连接的时候，会在 client hello 中携带上之前的 session-id，服务端通过 session-id 到内存中查找相关的 value，一旦找到就直接利用会话密钥恢复会话状态，在一个 rtt 内直接建立通信。\n"),s("ul",[s("li",[t._v("缺点1：服务端需要保存大量的会话状态（key-value），压力比较大")]),t._v(" "),s("li",[t._v("缺点2：若通过多台服务器进行负载均衡，客户端不一定会命中此前访问的服务器，那么还是得走完整的 TLS 连接流程")])])]),t._v(" "),s("li",[t._v("==session ticket==：服务端不再保留会话状态，而是把压力分散到客户端上 —— 即将此次会话的会话密钥进行加密，形成 ticket，发送给客户端。客户端保存 ticket，以后再次和服务端连接的时候，就发送 ticket 给服务端，服务端进行解密以获取会话密钥，双方再进行加密通信。")]),t._v(" "),s("li",[t._v("==pre-shared key==：不管是 session id 还是 session ticket，至少也都需要 1-rtt 才能恢复会话状态。而 TLS 1.3 提出的 pre-shared key 则只需要 0-rtt，它的原理和 session ticket 类似，但是客户端在再次连接时，会把 ticket 和 https 请求一并发送过去，这样，服务端若验证会话密钥没问题，就可以恢复会话状态，并在这第一次返回中响应数据给客户端。")])]),t._v(" "),s("p",[t._v("为了安全起见，这几种方式都需要验证会话密钥的有效期。")])])]),t._v(" "),s("h2",{attrs:{id:"https-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-的使用"}},[t._v("#")]),t._v(" HTTPS 的使用")]),t._v(" "),s("p",[t._v("那么如何开启使用 HTTPS 呢？在已经搞定证书的前提下，只需要配置一下 Nginx 即可。HTTP 监听的是 80 端口，现在要使用 HTTPS，则需要让它监听 443 端口。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("server "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// listen 80;")]),t._v("\n    listen "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("443")]),t._v(" ssl\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("当然，这里也可以选择继续监听 80 端口，然后通过配置 rewrite 实现端口重定向，让用户发送的 HTTP 请求重定向为 HTTPS 请求。")])])}),[],!1,null,null,null);v.default=e.exports}}]);