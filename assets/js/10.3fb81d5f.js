(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{550:function(t,e,v){"use strict";v.r(e);var a=v(12),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("在谈到浏览器缓存的时候，其实可以从两个角度出发。第一个是从缓存位置出发，浏览器存在四种不同位置的缓存；第二个是从具体的缓存策略出发，也就是我们经常说的强缓存和协商缓存。")]),t._v(" "),v("h2",{attrs:{id:"_1-缓存位置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存位置"}},[t._v("#")]),t._v(" 1）缓存位置")]),t._v(" "),v("h3",{attrs:{id:"service-worker-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-cache"}},[t._v("#")]),t._v(" Service Worker Cache")]),t._v(" "),v("p",[t._v("首先理解什么是 web worker，web worker 是一个独立于 JS 主线程之外的线程，可以执行一些耗时、耗资源的任务，从而分担主线程的压力。而 service worker 也属于一种 web worker，只是它更像是一个代理服务器，可以拦截请求和响应，实现资源的离线缓存 —— 这里的离线缓存其实就是 service worker cache。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("缓存控制")]),t._v("：由开发者通过 api 拦截请求或者响应，自己决定缓存什么资源，如何匹配资源等")]),t._v(" "),v("li",[v("strong",[t._v("缓存时长")]),t._v("：持久缓存。即使关闭了页面或者浏览器，缓存也依然存在。只有两种情况缓存会消失，一是手动调用 api 清除缓存，二是缓存容量达到浏览器的最大限制")]),t._v(" "),v("li",[v("strong",[t._v("功能")]),t._v("：用于离线存储资源，即使无网络环境下也可以使用")])]),t._v(" "),v("h3",{attrs:{id:"memory-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[t._v("#")]),t._v(" Memory Cache")]),t._v(" "),v("p",[t._v("位于内存中的缓存，缓存的是资源的引用")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("缓存控制")]),t._v("：完全由浏览器内部控制的")]),t._v(" "),v("li",[v("strong",[t._v("缓存时长")]),t._v("：临时缓存。关闭页面，进程就结束，内存就被销毁，内存缓存也会被清除")]),t._v(" "),v("li",[v("strong",[t._v("功能")]),t._v("：一般会缓存体积小的静态资源，内存读取速度比磁盘读取速度快很多")])]),t._v(" "),v("h3",{attrs:{id:"disk-cache-http-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache-http-cache"}},[t._v("#")]),t._v(" Disk Cache（Http Cache）")]),t._v(" "),v("p",[t._v("位于磁盘中的缓存，直接缓存资源本身")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("缓存控制")]),t._v("：可以通过头部字段控制缓存策略")]),t._v(" "),v("li",[v("strong",[t._v("缓存时长")]),t._v("：持久缓存。即使关闭了页面或者浏览器，缓存也依然存在。有效期一般通过 Expire 或者 Cache-Control 的 max-age 设置")]),t._v(" "),v("li",[v("strong",[t._v("功能")]),t._v("：一般会缓存体积大的静态资源，由于是存储在磁盘上，所以读取速度不如内存缓存快")])]),t._v(" "),v("h3",{attrs:{id:"push-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[t._v("#")]),t._v(" Push Cache")]),t._v(" "),v("p",[t._v("HTTP/2 引入了 server push，而 server push 使用的缓存叫做 push cache。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("缓存控制")]),t._v("：完全由浏览器内部控制")]),t._v(" "),v("li",[v("strong",[t._v("缓存时长")]),t._v("：临时缓存。会话结束缓存就消失，即使会话没结束，若过了五分钟，缓存也会消失")]),t._v(" "),v("li",[v("strong",[t._v("功能")]),t._v("：也可以缓存资源，但是缓存只能使用一次。浏览器为了实现优化，会让同域名的不同标签页共用同一个 HTTP/2 连接，而它们实际上也是会共用 push cache 的。")])]),t._v(" "),v("h3",{attrs:{id:"优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[t._v("#")]),t._v(" 优先级")]),t._v(" "),v("p",[t._v("首先，在缓存使用的优先级上，会按照 "),v("code",[t._v("Service Worker Cache --\x3e Memory Cache --\x3e Disk Cache --\x3e Push Cache")]),t._v(" 的顺序查找。")]),t._v(" "),v("p",[t._v("另一方面，用户的交互行为也会影响具体使用哪种缓存：")]),t._v(" "),v("ul",[v("li",[t._v("地址栏输入 url：优先查找 Disk Cache")]),t._v(" "),v("li",[t._v("F5 刷新：优先查找 Memory Cache，找不到再查找 Disk Cache")]),t._v(" "),v("li",[t._v("ctrl + F5 刷新：不使用缓存，重新请求")])]),t._v(" "),v("h2",{attrs:{id:"_2-缓存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存策略"}},[t._v("#")]),t._v(" 2）缓存策略")]),t._v(" "),v("p",[t._v("具体的缓存策略，分为强缓存和协商缓存两种。可以先通过下面这张图了解大概的过程：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/3.png",alt:""}})]),t._v(" "),v("h3",{attrs:{id:"优先进行强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优先进行强缓存"}},[t._v("#")]),t._v(" 优先进行强缓存")]),t._v(" "),v("ol",[v("li",[t._v("浏览器针对资源 A 初次发起请求，依次查看 ServiceWorker Cache、Memory Cache 和 Disk Cache 是否有缓存。因为没有，所以请求到达服务器，服务器返回资源和携带在头部字段中的缓存策略")]),t._v(" "),v("li",[t._v("浏览器这边"),v("strong",[t._v("自动缓存资源的引用")]),t._v("到 Memory Cache 中，同时"),v("strong",[t._v("根据头部字段")]),t._v("将资源缓存到 Disk Cache 中，如果开发者使用了 Service Worker Cache，也会对应做一个缓存")]),t._v(" "),v("li",[t._v("片刻后，用户再次针对资源 A 发起请求，浏览器会依次查看 Memory Cache 和 Disk Cache 是否有缓存，接着查看缓存是否新鲜（是否没有过期）\n"),v("ul",[v("li",[t._v("在 http/1.0 中，服务端会返回一个 Expires 头部字段，它是一个绝对的到期时间，只要浏览器再次发送请求的时候没有过这个时间，就认为缓存没有过期。")]),t._v(" "),v("li",[t._v("在 http/1.1 中，Expires 被 Cache-Control 取代。而 Cache-Control 可以设置一个 "),v("code",[t._v("max-age = <seconds>")]),t._v("，指的是从请求发起过了多少秒之后，缓存才会过期")])])]),t._v(" "),v("li",[t._v("如果缓存没有过期，那么恭喜，这时候可以直接从 Disk Cache 中获取资源 A 并返回，我们称这种情况为命中强缓存、走强缓存路线。")])]),t._v(" "),v("p",[v("strong",[t._v("关于 Expires 字段和 Cache-Control 字段")])]),t._v(" "),v("p",[t._v("Expires 是 HTTP/1.0 的产物，Cache-Control 是 HTTP/1.1 的产物，这两个字段都指定了缓存的有效期。")]),t._v(" "),v("blockquote",[v("p",[t._v("为什么优先使用 Cache-Control 字段？")])]),t._v(" "),v("p",[t._v("这是因为使用 Expires 字段是不精确的。它来自于服务器那边的时间，但比较是否过期的时候，浏览器是拿自己的本地时间与之进行比较的，如果双端时间不同步，那么就会导致缓存过期的判定出现问题。")]),t._v(" "),v("p",[t._v("而 Cache-Control 字段设置的其实是一个相对时间，相对时间就不存在误差了。更重要的是，它还提供了其它选项对缓存策略进行控制：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("过期时间：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("规则")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("功能")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("max-age = 5")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("取代 expires，指定缓存的有效期。自上次请求过去 5 秒后，缓存才过期。"),v("strong",[t._v("对于不经常变动且想要缓存的资源，可以给定一个很大的 max-age 值，再配合 url 实现更新")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("s-maxage = 5")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("可以覆盖 max-age，但只有缓存是 public 的时候才生效；若缓存是 private，则无效")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("max-stale = 5")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("允许客户端使用过期的缓存，但是最多允许过期 5s，过期超过 5s 就不能用了")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("min-fresh = 5")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("客户端要求一个新鲜的、未过期的缓存，并且至少过了 5s 还是新鲜的")])])])])]),t._v(" "),v("li",[v("p",[t._v("可缓存性：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("规则")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("功能")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("public")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("浏览器和代理服务器都可以缓存资源")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("private")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("只有浏览器可以缓存资源")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("no-store")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不可以缓存资源，不会有强缓存和协商缓存之说")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("no-cache")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("可以缓存资源，但是无论资源是否过期，都需要向服务端验证资源是否更改。"),v("strong",[t._v("比较适用于那些经常更改的资源")])])])])])])]),t._v(" "),v("blockquote",[v("p",[t._v("Cache-Control 可以取代 Expires 吗？")])]),t._v(" "),v("p",[t._v("答案是暂时不能。在某些不支持 HTTP/1.1 的环境中，为了实现向下兼容，仍然需要使用 Expires。")]),t._v(" "),v("h3",{attrs:{id:"其次进行协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其次进行协商缓存"}},[t._v("#")]),t._v(" 其次进行协商缓存")]),t._v(" "),v("p",[t._v("如果缓存已经过期，那么浏览器就需要和服务器进行协商，协商的内容就是：我应该继续使用这个已经过期的缓存资源，还是使用可能已经发生更新的新资源？这时候称为没有命中强缓存、走协商缓存路线。")]),t._v(" "),v("p",[t._v("​\t1）如果第一次的响应携带了 ETag 字段：浏览器将 ETag 的字段值作为 If-None-Match 的字段值，向服务器发送条件请求，相当于是在问服务器：==当时发送资源给我的时候，这个资源的唯一标识是 ETag，是否这个哈希值仍然和资源的目前最新的哈希值一致呢？==服务器就会拿收到的这个字段值与目前最新的资源哈希值进行比较，如果一致说明资源没有发生修改，此时返回 304 状态码，让浏览器使用之前的旧缓存；如果不一致说明资源发生了修改，此时重新响应 200 和新资源给浏览器")]),t._v(" "),v("p",[t._v("​\t2）如果第一次的响应没有携带 ETag 字段，但是携带了 Last-Modified 字段：浏览器将 Last-Modified 的字段值作为 If-Modified-Since 的字段值，向服务器发送条件请求，相当于是在问服务器：==当时发送资源给我的时候，最后一次修改资源的时间是 Last-Modified，是否自从这个时间之后，资源没有再次被修改呢？==服务器就会拿收到的这个字段值与目前最新的资源修改时间进行比较，如果时间吻合说明资源没有发生修改，此时返回 304 状态码，让浏览器使用之前的旧缓存；如果时间不吻合说明资源发生了修改，此时重新响应 200 和新资源给浏览器")]),t._v(" "),v("p",[t._v("​\t3）如果两个字段都没有携带：此时就进行正常的请求响应")]),t._v(" "),v("p",[v("strong",[t._v("关于 Last-Modified 字段和 ETag 字段")])]),t._v(" "),v("blockquote",[v("p",[t._v("为什么优先使用 ETag 字段？")])]),t._v(" "),v("p",[t._v("使用 Last-Modified 进行校验，实际上会有两个问题，而这两个问题会影响到关于“资源是否真的发生了修改”的判断：")]),t._v(" "),v("ul",[v("li",[t._v("其一，把没修改当成了修改。Last-Modified 更准确地说应该是上次编辑时间而不是上次修改时间，所谓编辑，意思就是不一定发生了修改，或者发生的是无关紧要的修改，但由于编辑时间确实改动了，所以服务器给出的结果依然是资源发生了修改；")]),t._v(" "),v("li",[t._v("其二，把修改当成了没修改。Last-Modified 最小只能精确到秒这个量级，这就是说，如果资源在一秒内发生了多次修改，其实服务器是看不出来的，给出的结果依然是资源没有发生修改。")])]),t._v(" "),v("p",[t._v("而如果是使用 ETag 进行校验，因为它本质上是基于文件内容进行编码所产生的哈希值，可以精确地感知文件内容的变化，所以用来判断资源是否发生修改，准确性会很高。")]),t._v(" "),v("blockquote",[v("p",[t._v("ETag 可以取代 Last-Modified 吗？")])]),t._v(" "),v("p",[t._v("ETag 不是银弹，应该将其视为 Last-Modified 的补充和强化，而不是替代品。ETag 本身也有缺点，那就是每次 ETag 的生成都需要进行一次哈希计算，对服务器的性能有一定的影响。而相反的，Last-Modified 只需要记录一个时间，性能要好很多。")]),t._v(" "),v("h2",{attrs:{id:"代理服务器缓存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器缓存机制"}},[t._v("#")]),t._v(" 代理服务器缓存机制")]),t._v(" "),v("p",[t._v("这里只说一下响应报文中 vary 头部字段在代理服务器缓存中的作用。实际上，vary 字段是协助进行内容协商的，可以防止客户端错误返回缓存资源。")]),t._v(" "),v("p",[t._v("假设有两个客户端 A 和 B，A 支持 gzip 编码而 B 不支持。")]),t._v(" "),v("ul",[v("li",[t._v("第一次 A 发出请求，经代理服务器转发后到达服务器，服务器返回资源到代理服务器，并且会在响应报文中增加一个 vary 字段，比如说 vary：accept-encoding。代理服务器会针对资源做一个缓存，同时通过响应报文中的 vary 给资源打上一个标记，比如 accept-encoding：gzip，代表这个资源是使用 gzip 编码压缩的。")]),t._v(" "),v("li",[t._v("假设 A 在片刻后发出第二次请求，还是请求同样的资源，因为也有一个 accept-encoding：gzip，所以代理服务器可以返回缓存给客户端 A")]),t._v(" "),v("li",[t._v("之后假设 B 也发出了一次请求，但是由于 B 不支持 gzip 编码，所以是不携带 accept-encoding：gzip 字段的，代理服务器不会把缓存的这个资源返回给 B")])]),t._v(" "),v("p",[t._v("因此 vary 实际上就相当于是给代理服务器的缓存资源打上一个标记，如果当时源服务器不返回 vary 字段，那么 B 请求资源的时候，代理服务器会错误地把资源返回给 B，而 B 是使用不了这个资源的，因为它不支持 gzip 编码。")])])}),[],!1,null,null,null);e.default=_.exports}}]);