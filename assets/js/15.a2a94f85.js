(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{554:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("极客时间《浏览器工作原理与实践》学习笔记")])]),t._v(" "),a("h2",{attrs:{id:"关于浏览器的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于浏览器的架构"}},[t._v("#")]),t._v(" 关于浏览器的架构")]),t._v(" "),a("h3",{attrs:{id:"架构的选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构的选择"}},[t._v("#")]),t._v(" 架构的选择")]),t._v(" "),a("blockquote",[a("p",[t._v("现代浏览器采用的是多进程的架构")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("为什么不能是单线程？")]),t._v(" "),a("p",[t._v("浏览器肯定要并行处理任务，即在同一段时间内做多件事情，比如渲染页面、发送请求、处理用户输入等，而单线程注定了同一时间只能做一件事情，因此不能采用单线程架构。")])]),t._v(" "),a("li",[a("p",[t._v("为什么不能是单进程多线程？")]),t._v(" "),a("p",[t._v("而如果采用单进程多线程架构，则 ① 如果存在恶意线程，则会影响其它正常线程，无法保证安全性；② 一个线程的崩溃会导致整个进程的崩溃，无法保证稳定性。③ 资源和数据都是共享的，无法保证互相之间的隔离")])]),t._v(" "),a("li",[a("p",[t._v("为什么是多进程？")]),t._v(" "),a("p",[t._v("现代浏览器采用的是类似操作系统那样的多进程架构，好处很多。进程和进程之间是互相隔离的，能够很好地保证安全性和稳定性。当然也有缺点，就是带来更高的资源占用。")])])]),t._v(" "),a("h3",{attrs:{id:"核心进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心进程"}},[t._v("#")]),t._v(" 核心进程")]),t._v(" "),a("p",[t._v("现代浏览器一般有以下几个核心进程：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器主进程")]),t._v(" "),a("li",[t._v("GPU 进程")]),t._v(" "),a("li",[t._v("网络进程")]),t._v(" "),a("li",[t._v("插件进程")]),t._v(" "),a("li",[t._v("渲染进程")])]),t._v(" "),a("p",[t._v("其中，渲染进程会针对服务器返回的资源进行 HTML 解析、CSS 解析、图片解码等。如果这些资源存在问题，浏览器又存在漏洞，那么黑客就可能会控制渲染进程，进而控制操作系统。因此，为了安全起见，最好是将渲染进程单独隔离起来。")]),t._v(" "),a("p",[t._v("具体地说，浏览器会分为两个内核模块，一个是渲染内核，指的是单独运行在安全沙箱中的渲染进程；一个是浏览器内核，包含了其它进程。这样，即便渲染进程出现了安全漏洞被攻破，由于沙箱的隔离作用，操作系统也不会受到影响。")]),t._v(" "),a("p",[t._v("渲染进程采⽤了安全沙箱固然保证了安全，但也导致渲染进程内部不能与操作系统直接交互，于是就在浏览器内核中实现了持久存储、⽹络访问和⽤⼾交互等⼀系列与操作系统交互的功能，然后通过 IPC 和渲染进程进⾏交互。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/1.jpg"}}),t._v(" "),a("h2",{attrs:{id:"浏览器页面的渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器页面的渲染"}},[t._v("#")]),t._v(" 浏览器页面的渲染")]),t._v(" "),a("h3",{attrs:{id:"渲染进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程"}},[t._v("#")]),t._v(" 渲染进程")]),t._v(" "),a("p",[a("strong",[t._v("一般来说")]),t._v("，每打开一个标签页，就会有一个新的渲染进程；但有一种例外情况是，如果通过 a 页面打开了 b 页面，并且两个页面属于同站（"),a("code",[t._v("same-site")]),t._v("，即协议和根域名都一样），那么 b 页面不会重开一个渲染进程，而是会复用父页面即 a 页面的渲染进程。渲染进程包括以下6个线程：")]),t._v(" "),a("ul",[a("li",[t._v("GUI 渲染线程：内含渲染引擎，负责 HTML、CSS 的解析以及 DOM tree 和 CSSOM tree 的构建")]),t._v(" "),a("li",[t._v("JS 引擎线程：内含 JS 引擎，负责 JS 的解析和执行")]),t._v(" "),a("li",[t._v("事件触发线程")]),t._v(" "),a("li",[t._v("定时器触发线程")]),t._v(" "),a("li",[t._v("异步 http 请求线程")]),t._v(" "),a("li",[t._v("合成线程")]),t._v(" "),a("li",[t._v("IO 线程")])]),t._v(" "),a("p",[t._v("==Note==：GUI 渲染线程和 JS 引擎线程必须是互斥的。打个比方，渲染线程在解析 HTML 准备构建 DOM 树的时候，JS 引擎线程不能同时去解析和执行 JS，否则可能在涉及 DOM 的操作上发生冲突。一定要注意，这两者不是单线程的，它们是独立的两个线程，只是互斥而已。")]),t._v(" "),a("h3",{attrs:{id:"渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[t._v("#")]),t._v(" 渲染过程")]),t._v(" "),a("p",[t._v("具体的渲染过程，可以参考 "),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzkyOTIxMDAzNw==&mid=2247486121&idx=1&sn=784cf2cb27f0fefdee652a0641cf83d3&source=41#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("从输入 URL 到页面呈现的过程"),a("OutboundLink")],1),t._v(" 这篇文章。这里主要记录大致的流程和一些细节。")]),t._v(" "),a("h4",{attrs:{id:"渲染过程一览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程一览"}},[t._v("#")]),t._v(" 渲染过程一览")]),t._v(" "),a("h5",{attrs:{id:"_1-html-解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-html-解析"}},[t._v("#")]),t._v(" 1）HTML 解析")]),t._v(" "),a("p",[t._v("解析 HTML ，构建 DOM 树")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/2.jpg",alt:""}})]),t._v(" "),a("h5",{attrs:{id:"_2-样式计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-样式计算"}},[t._v("#")]),t._v(" 2）样式计算")]),t._v(" "),a("p",[t._v("解析 CSS，构建 CSSOM 树（或者说 styleSheets，暂且认为是同一个东西）。之后对所有属性值进行标准化，然后基于继承和层叠规则计算每个节点的具体样式。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/3.jpg"}}),t._v(" "),a("h5",{attrs:{id:"_3-布局-layout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-布局-layout"}},[t._v("#")]),t._v(" 3）布局（layout）")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("生成布局树：DOM  树和 CSSOM 树结合，形成布局树，布局树只会包含实际显示在页面上的节点（因此不会包含 "),a("code",[t._v("<head>")]),t._v(" 节点，隐藏的节点等）。")])]),t._v(" "),a("li",[a("p",[t._v("布局计算：计算布局树中节点的具体坐标位置")])])]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/4.jpg"}}),t._v(" "),a("h5",{attrs:{id:"_4-分层-layer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-分层-layer"}},[t._v("#")]),t._v(" 4）分层（layer）")]),t._v(" "),a("p",[t._v("因为 "),a("code",[t._v("z-index")]),t._v(" 和 CSS 3D 变换等的存在，页面通常不是一个简单的平面，而是有很多图层。分层指的是针对布局树中的特定节点生成属于它的图层，而多个图层会构建起一棵图层树。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/5.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("注意不是所有节点都会有一个属于自己的图层，像上图中的 "),a("code",[t._v("span")]),t._v(" 就和它的父元素 "),a("code",[t._v("div")]),t._v(" 共用一个图层")]),t._v(" "),a("li",[t._v("什么样的节点会有属于自己的图层？一个是具有层叠上下文属性的节点，一个是节点本身需要被裁剪（典型的，比如 "),a("code",[t._v("div")]),t._v(" 中放不下文字，那么文字就需要被“裁剪”，此时文字会产生一个自己的图层）")])]),t._v(" "),a("h5",{attrs:{id:"_5-绘制-paint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-绘制-paint"}},[t._v("#")]),t._v(" 5）绘制（paint）")]),t._v(" "),a("p",[t._v("每个图层的绘制依赖于一个个很小的绘制指令，这些绘制指令按顺序组成了一个绘制列表")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/6.jpg"}}),t._v(" "),a("p",[t._v("接着将绘制列表提交给合成线程，合成线程将图层分为多个图块")]),t._v(" "),a("blockquote",[a("p",[t._v("这里之所以要将图层分块处理，是因为视口决定了用户一次可以看到的页面内容是有限的，若一次性将整个图层渲染出来，会对性能有一定影响")])]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/7.jpg"}}),t._v(" "),a("h5",{attrs:{id:"_6-栅格化-光栅化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-栅格化-光栅化"}},[t._v("#")]),t._v(" 6）栅格化（光栅化）")]),t._v(" "),a("p",[t._v("将图块提交给栅格化线程池，图块经过栅格化转化为位图")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/8.jpg"}}),t._v(" "),a("p",[t._v("栅格化的过程可能会使用 GPU 加速，最终生成位图的操作实际是在 GPU 中完成的。因此这里可能涉及到了跨进程操作：\n"),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/9.jpg"}})]),t._v(" "),a("h5",{attrs:{id:"_7-合成和显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-合成和显示"}},[t._v("#")]),t._v(" 7）合成和显示")]),t._v(" "),a("p",[t._v("一旦所有图块被栅格化成位图，这些位图会返回给合成线程，合成线程再发送一个 "),a("code",[t._v("DrawQrud")]),t._v(" 绘制指令给浏览器主进程，浏览器主进程接受该指令，将页面内容绘制到内存中，然后将内存中的页面发送给显卡的后缓冲区，显卡再通过显示器将最终内容显示到屏幕上。")]),t._v(" "),a("h4",{attrs:{id:"资源引用对-html-解析的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源引用对-html-解析的影响"}},[t._v("#")]),t._v(" 资源引用对 HTML 解析的影响")]),t._v(" "),a("p",[t._v("在浏览器向服务器发送请求后，服务器会返回 HTML 文件。浏览器对 HTML 文件进行解析（或者说对 DOM 进行解析），构建 DOM 树，在解析 HTML 的过程中，不可避免会遇到 "),a("code",[t._v("<script>")]),t._v(" 和 "),a("code",[t._v("<link>")]),t._v("，那么这会对 HTML 的解析产生什么影响呢？")]),t._v(" "),a("h5",{attrs:{id:"_1-外联-script-对-html-解析的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-外联-script-对-html-解析的影响"}},[t._v("#")]),t._v(" 1. 外联 "),a("code",[t._v("<script>")]),t._v(" 对 HTML 解析的影响")]),t._v(" "),a("blockquote",[a("p",[t._v("外联 "),a("code",[t._v("<script>")]),t._v(" 可能会阻塞 DOM 的解析和渲染")])]),t._v(" "),a("p",[t._v("从位置上来看，如果外联 "),a("code",[t._v("<script>")]),t._v(" 是放在 "),a("code",[t._v("</body>")]),t._v(" 上方，那么其实是不会对 DOM 的解析造成影响的，因为肯定是在 DOM 解析完毕之后再去加载并执行 JS 代码；如果外联 "),a("code",[t._v("<script>")]),t._v(" 是放在其它位置，那么根据 "),a("code",[t._v("<script>")]),t._v(" 标签不加声明、使用 "),a("code",[t._v("async")]),t._v(" 声明或者使用 "),a("code",[t._v("defer")]),t._v(" 声明，对 DOM 解析的影响会有所不同。其区别可以用下面这张图形象地表示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://image-static.segmentfault.com/144/351/1443517782-57c6928b20b56_articlex",alt:""}})]),t._v(" "),a("p",[t._v("整个过程主要和浏览器的渲染进程有关，绿色线表示 GUI 渲染线程，负责解析 HTML 和构建 DOM 树的工作，蓝色线表示异步 http 请求线程，负责请求并下载 JS 文件，红色线表示 JS 引擎线程，负责解析并执行 JS 代码。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("不加声明：")]),t._v(" "),a("p",[t._v("在解析 HTML 的过程中，若碰到 "),a("code",[t._v("<script>")]),t._v(" 标签，会马上停止解析，由异步 http 请求线程和 JS 引擎线程分别去下载和执行代码，执行完毕之后再由 GUI 渲染线程接手，继续解析 HTML。注意，虽然网络请求和 HTML 解析完全可以并行，但在这里不会这样，在进行网络请求之前，HTML 的解析就已经被阻塞了。")]),t._v(" "),a("p",[t._v("既然 HTML（DOM）的解析被阻塞了，那么 DOM 的渲染也是被阻塞的。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("async")]),t._v(" 声明：")]),t._v(" "),a("p",[t._v("在解析 HTML 的过程中，若碰到 "),a("code",[t._v("<script>")]),t._v(" 标签，异步 http 请求线程会去"),a("strong",[t._v("并行地")]),t._v("请求并加载 JS 文件，同时 HTML 仍然继续解析，直到 JS 文件加载完毕，此时 HTML 解析才会停止，交由 JS 引擎线程去执行代码，执行完毕后再继续解析 HTML。在声明 "),a("code",[t._v("async")]),t._v(" 的情况下，代码的执行时机取决于 JS 文件加载完成的时机，而文件加载完成的时机通常是不确定的，因此代码的执行时机也是不确定的，顺序引用的 JS 文件在执行上可能是乱序的，这就会导致存在依赖的 JS 文件执行时出现问题。比如 A.js 依赖于 B.js，而它执行的时候 B.js 尚未执行，这时候 A.js 的执行就会出问题。")]),t._v(" "),a("p",[t._v("同样的，既然 HTML（DOM）的解析被阻塞了，那么 DOM 的渲染也是被阻塞的。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("defer")]),t._v(" 声明：")]),t._v(" "),a("p",[t._v("在解析 HTML 的过程中，若碰到 "),a("code",[t._v("<script>")]),t._v(" 标签，异步 http 请求线程会去"),a("strong",[t._v("并行地")]),t._v("请求并加载 JS 文件，同时 HTML 仍然继续解析，解析的过程中 JS 文件可能已经加载完毕，但解析完全不会被打断，直到 HTML 解析结束，JS 文件才会被执行。也就是说，"),a("code",[t._v("defer")]),t._v(" 声明会在最大程度上保证 HTML 解析过程的顺利执行。")])])]),t._v(" "),a("p",[t._v("==Note：==无论是哪种声明方式，HTML 的解析以及 JS 的执行都不可能同时进行，这不是因为它们是单线程的，而是因为这两个线程是互斥的。")]),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("p",[t._v("https://javascript.tutorialhorizon.com/2015/08/11/script-async-defer-attribute/")]),t._v(" "),a("p",[t._v("https://juejin.cn/post/6844903936877395981#heading-0")]),t._v(" "),a("h5",{attrs:{id:"_2-内联-script-对-html-解析的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-内联-script-对-html-解析的影响"}},[t._v("#")]),t._v(" 2. 内联 "),a("code",[t._v("<script>")]),t._v(" 对 HTML 解析的影响")]),t._v(" "),a("blockquote",[a("p",[t._v("内联 "),a("code",[t._v("<script>")]),t._v(" 一定会阻塞 DOM 的解析和渲染")])]),t._v(" "),a("p",[t._v("前面说的是外联 "),a("code",[t._v("<script>")]),t._v(" 的情况，所谓外联那必然就要请求 JS 文件，所以不声明 "),a("code",[t._v("async")]),t._v(" 和 "),a("code",[t._v("defer")]),t._v("、只声明 "),a("code",[t._v("async")]),t._v(" 以及只声明 "),a("code",[t._v("defer")]),t._v(" 是有区别的；但如果是内联的 "),a("code",[t._v("<script>")]),t._v("，那么就不存在请求 JS 文件的说法，"),a("code",[t._v("async")]),t._v(" 和 "),a("code",[t._v("defer")]),t._v(" 的属性声明也就不生效了。")]),t._v(" "),a("p",[t._v("内联 "),a("code",[t._v("<script>")]),t._v(" 的情况简单很多，只要遇到 "),a("code",[t._v("<script>")]),t._v(" 标签，HTML 的解析就会停止，先去执行 JS 代码，执行完毕后再继续解析 HTML。")]),t._v(" "),a("h5",{attrs:{id:"_3-link-对-dom-解析和渲染的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-link-对-dom-解析和渲染的影响"}},[t._v("#")]),t._v(" 3. "),a("code",[t._v("<link>")]),t._v(" 对 DOM 解析和渲染的影响")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("<link>")]),t._v(" 不会阻塞 DOM 的解析，但会阻塞 DOM 的渲染")])]),t._v(" "),a("p",[t._v("实际上，可以认为 GUI 渲染线程会"),a("strong",[t._v("并行")]),t._v("做两件事，一个是解析 HTML（解析 DOM），构建 DOM 树；一个是解析 CSS，构建 CSSOM 树，两者互不影响。因此，"),a("code",[t._v("<link>")]),t._v(" 并不会阻塞 DOM 的解析，一旦遇到 "),a("code",[t._v("<link>")]),t._v("，只需要让异步 http 请求线程去请求并加载 CSS 文件，之后对 CSS 解析即可，与此同时，DOM 的解析仍可正常继续进行。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/19/16fbc62f1264cb8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),t._v(" "),a("p",[t._v("但是，页面最终能够渲染出来，依靠的是 DOM 树和 CSSOM 树合并形成的 render 树（layout 树），因此，"),a("code",[t._v("<link>")]),t._v(" 是会阻塞 DOM（或者说页面）的渲染的。")]),t._v(" "),a("h5",{attrs:{id:"_4-css-对-js-执行的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-css-对-js-执行的影响"}},[t._v("#")]),t._v(" 4. CSS 对 JS 执行的影响")]),t._v(" "),a("p",[t._v("此外，解析  "),a("code",[t._v("<link>")]),t._v(" （或者说 CSS）的时候是会阻塞 JS 执行的。一方面，由于 CSS 的解析在 GUI 渲染线程上进行，JS 的执行在 JS 引擎线程上进行，这两个线程互斥，因此解析 "),a("code",[t._v("<link>")]),t._v(" 与执行 JS 不可能同时进行；另一方面，若二者同时进行，JS 可能会访问当时尚未解析出来的样式信息，导致执行上出错，从这个角度说，在设计上也不应该让他们两者可以同时进行。")]),t._v(" "),a("h5",{attrs:{id:"_5-如何理解阻塞-dom-的渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何理解阻塞-dom-的渲染"}},[t._v("#")]),t._v(" 5. 如何理解阻塞 DOM 的渲染？")]),t._v(" "),a("p",[t._v("如果说阻塞 DOM（页面）的渲染就是让页面一片空白，什么也没有的话，那么用户体验是非常差的。所以，这里的阻塞指的是阻塞后续 DOM 的渲染，遇到 "),a("code",[t._v("<script>")]),t._v(" 之前的 DOM 渲染不仅不会阻塞，还会基于它们触发一次 paint，提前将这部分内容显示出来。但不是什么 "),a("code",[t._v("<script>")]),t._v(" 都会触发 paint，下面是例外：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("<head>")]),t._v(" 中的 "),a("code",[t._v("<script>")]),t._v(" 不会触发，因为此时甚至连 "),a("code",[t._v("<body>")]),t._v(" 都还没解析，触发了也没有什么内容可以显示")]),t._v(" "),a("li",[t._v("内联的 "),a("code",[t._v("<script>")]),t._v(" 不会触发")])]),t._v(" "),a("h3",{attrs:{id:"重排和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排和重绘"}},[t._v("#")]),t._v(" 重排和重绘")]),t._v(" "),a("h4",{attrs:{id:"重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[t._v("#")]),t._v(" 重排")]),t._v(" "),a("p",[t._v("重排即 "),a("code",[t._v("reflow")]),t._v("，也叫回流。如果通过 CSS 或者 JS 修改某个元素的几何位置属性，比如修改了宽高等，那么其它元素的布局也可能跟着改变，这会触发浏览器的重新布局，从 style（计算样式）这一步开始将整个渲染流水线重新走一遍（如果是修改了 DOM 结构，那么 DOM 树也需要重新构建）。因此，重排的开销是非常大的。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/10.jpg"}}),t._v(" "),a("blockquote",[a("p",[t._v("重排发生的关键在于布局的改变。以下场景会引起重排：")])]),t._v(" "),a("ul",[a("li",[t._v("页面渲染初始化")]),t._v(" "),a("li",[t._v("添加或者删除可见的 DOM 元素")]),t._v(" "),a("li",[t._v("元素位置改变")]),t._v(" "),a("li",[t._v("元素大小改变（包括宽高、内外边距、边框）")]),t._v(" "),a("li",[t._v("元素的 "),a("code",[t._v("display")]),t._v(" 改变（"),a("code",[t._v("none")]),t._v(" 和 "),a("code",[t._v("block")]),t._v(" 切换）")]),t._v(" "),a("li",[t._v("填充内容改变，比如修改文本、修改图片大小等")]),t._v(" "),a("li",[t._v("激活伪类（鼠标移入移出等）")]),t._v(" "),a("li",[t._v("浏览器窗口尺寸改变（触发 resize 事件）")]),t._v(" "),a("li",[t._v("读取某些样式属性（和浏览器的渲染队列有关，后面解释）")])]),t._v(" "),a("p",[t._v("PS：设置了绝对定位或者固定定位的元素脱离了正常文档流，修改 "),a("code",[t._v("top")]),t._v(" 等值只会引起自身重排，不会影响到其它元素，因此重排的开销相对来说比较小。（注意不是不发生重排，毕竟元素的位置是改变了的）")]),t._v(" "),a("h4",{attrs:{id:"重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),a("p",[t._v("重绘即 "),a("code",[t._v("repaint")]),t._v("。比如修改了某个元素的背景颜色，那么会从 paint（绘制）这一步开始将整个渲染流水线重新走一遍。注意重绘并不会重新走一遍 layout 和 layer，因为我们只是修改了颜色，浏览器只需要重新“绘画”，布局和分层不会受到影响。")]),t._v(" "),a("p",[t._v("从图中可以看出，重排是包含重绘的，发生了重排，那么也一定会发生重绘，而发生了重绘则不一定会发生重排。虽然重绘也有一定的性能开销，但因为不需要重新进行布局和分层，所以执行效率要比重排高。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/11.jpg"}}),t._v(" "),a("blockquote",[a("p",[t._v("重绘发生的关键在于外观的改变。以下场景会引起重绘：")])]),t._v(" "),a("ul",[a("li",[t._v("所有会引起重排的操作")]),t._v(" "),a("li",[t._v("修改下面这些属性：\n"),a("ul",[a("li",[t._v("color、visibility、text-decoration、font-family、opacity（除非将元素提升到合成层）")]),t._v(" "),a("li",[t._v("background、background-image、background-position、background-repeat、background-size")]),t._v(" "),a("li",[t._v("outline、outline-color、outline-style、outline-width")]),t._v(" "),a("li",[t._v("border-radius、border-style、box-shadow")]),t._v(" "),a("li",[t._v("具体的属性可以到 "),a("a",{attrs:{href:"https://csstriggers.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("csstrigger"),a("OutboundLink")],1),t._v(" 查看，注意浏览器之间的差别")])])])]),t._v(" "),a("h4",{attrs:{id:"渲染队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染队列"}},[t._v("#")]),t._v(" 渲染队列")]),t._v(" "),a("blockquote",[a("p",[t._v("前面说过读取某些样式属性的时候会触发重排 + 重绘，明明只是读取属性而没有修改属性，为什么还会引起重排和重绘呢？这需要从浏览器的渲染队列讲起")])]),t._v(" "),a("p",[t._v("看下面这段代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("根据前面的分析，这段代码应该引起四次重排，但由于渲染队列的存在，实际上只引起一次重排。")]),t._v(" "),a("p",[t._v("从优化的角度出发，浏览器不会每执行一句代码就进行一次重排，而是先把这些会引起重排或者重绘的操作放到一个渲染队列中，等到队列中的"),a("strong",[t._v("操作达到一定数量")]),t._v("或者"),a("strong",[t._v("到了一定的时间间隔")]),t._v("之后，再 flush （清空）队列，批量执行这些操作，这样就将原本的四次重排压缩到了一次。")]),t._v(" "),a("p",[a("strong",[t._v("强制 / 手动 flush 队列：")])]),t._v(" "),a("p",[t._v("当我们访问下面这些样式属性的时候：")]),t._v(" "),a("ul",[a("li",[t._v("offsetTop, offsetLeft, offsetWidth, offsetHeight")]),t._v(" "),a("li",[t._v("scrollTop, scrollLeft, scrollWidth, scrollHeight")]),t._v(" "),a("li",[t._v("clientTop, clientLeft, clientWidth, clientHeight")]),t._v(" "),a("li",[t._v("getComputedStyle(), 或者 IE 的 currentStyle")])]),t._v(" "),a("p",[t._v("我们肯定希望得到最新的属性值，而渲染队列中的操作很可能会影响到这些属性值，因此，浏览器为了确保我们可以得到最新的属性值，会先去 flush 一次队列，将队列里的操作马上批量执行一遍，以对属性值进行可能的更新。而这次 flush 就会触发一次重排 + 重绘。")]),t._v(" "),a("p",[t._v("再看修改之后的代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetLeft"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetTop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetWidth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetHeight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("每次修改属性之后都即时对属性进行了访问，虽然修改属性之后不会马上触发重排，但是紧接着的访问操作会 flush 队列并触发重排。这段代码总共会触发四次重排。")]),t._v(" "),a("blockquote",[a("p",[t._v("Note：尽量避免频繁访问这些属性，每次访问可能都意味着一次重排")])]),t._v(" "),a("h4",{attrs:{id:"性能优化-如何减少重排和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化-如何减少重排和重绘"}},[t._v("#")]),t._v(" 性能优化：如何减少重排和重绘")]),t._v(" "),a("p",[t._v("既然重排和重绘都会造成一定的性能开销，那么如何减少重排和重绘呢？")]),t._v(" "),a("h5",{attrs:{id:"_1-分离读写操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-分离读写操作"}},[t._v("#")]),t._v(" 1）分离读写操作")]),t._v(" "),a("p",[t._v("拿这段代码举例：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetLeft"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetTop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetWidth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetHeight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("它是一写一读的，每次读的时候都会刷新渲染队列，把上次的写操作实际执行，从而触发重排。")]),t._v(" "),a("p",[t._v("但是如果改成下面这种方式：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetLeft"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetTop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetWidth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetHeight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("那么前四次写操作可以依次进入渲染队列，之后遇到第一次读操作的时候发生队列刷新，执行所有写操作，整个过程只触发了一次重排。")]),t._v(" "),a("blockquote",[a("p",[t._v("分离读写操作的另外一种形式是利用变量缓存布局信息：")])]),t._v(" "),a("p",[t._v("假设当前渲染队列非空，那么这段代码将会触发两次重排：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetLeft "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetTop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("而如果是这段代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" curLeft "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetLeft"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" curTop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" div"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetTop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curLeft "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("top "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curTop "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("那么相当于是将读操作的结果寄放在变量里，从而实现读写分离。这样，我们仅在第一次通过 "),a("code",[t._v("div.offsetLeft")]),t._v(" 进行读操作的时候会触发一次重排。")]),t._v(" "),a("h5",{attrs:{id:"_2-样式集中一次修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-样式集中一次修改"}},[t._v("#")]),t._v(" 2）样式集中一次修改")]),t._v(" "),a("p",[t._v("现代浏览器大多支持渲染队列机制，可以保证连续的写操作不会触发连续的重排，但是旧的浏览器怎么办呢？我们通常会想办法集中一次修改样式。")]),t._v(" "),a("p",[t._v("比如使用 "),a("code",[t._v("cssText")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("el"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cssText "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"left:10px;top:10px;width:20px;height:20px"')]),t._v("\n")])])]),a("p",[t._v("或者给元素添加一个类：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("new_class "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    left"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    top"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    width"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    height"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("classList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"new_class"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h5",{attrs:{id:"_3-脱离文档的-dom-树-布局树-执行操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-脱离文档的-dom-树-布局树-执行操作"}},[t._v("#")]),t._v(" 3）脱离文档的 DOM 树（布局树）执行操作")]),t._v(" "),a("p",[t._v("既然修改直接来自 DOM 树中的节点可能会引发重排重绘，那么我们可以想办法让节点以某种形式”暂时脱离原有的 DOM 树“，执行完操作之后，再让它“回归到 DOM 树中”。以下有三种方式都是基于这个原理的。")]),t._v(" "),a("p",[a("strong",[t._v("方式一：隐藏元素 => 执行操作 => 显示元素：")])]),t._v(" "),a("p",[t._v("前面说过，布局树中只会包含最终可见的元素，因此只要给元素设置 "),a("code",[t._v("display: none")]),t._v("，那么它就会脱离布局树，修改它的任何属性也自然不会引起页面的重排和重绘。在修改完之后，我们只要让元素重新显示即可。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("el"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("display "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"none"')]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"10px"')]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("display "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"block"')]),t._v("\n")])])]),a("p",[t._v("注意：这种方式只是避免了两次 "),a("code",[t._v("display")]),t._v(" 之间的属性修改操作带来的重排和重绘，但每次 "),a("code",[t._v("display")]),t._v(" 的时候还是会触发一次重排。总的来说，它可以将重排的次数压缩到两次。")]),t._v(" "),a("blockquote",[a("p",[t._v("这里的 display 如果改为使用 visibility 会怎么样？")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("el"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("visibility  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hidden"')]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"10px"')]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("visibility "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"visible"')]),t._v("\n")])])]),a("p",[t._v("设置了 "),a("code",[t._v("visibility: hidden")]),t._v(" 的元素仍然占据页面空间，也没有从布局树中消失，只是视觉上看不见而已。因此在设置 "),a("code",[t._v("visibility")]),t._v(" 的时候不会触发重排，只会触发重绘。而正由于它没有从布局树中消失，所以两次 "),a("code",[t._v("visibility")]),t._v(" 之间的属性修改操作是可能会带来重排和重绘的。")]),t._v(" "),a("p",[t._v("也就是说，相比 "),a("code",[t._v("display")]),t._v("，"),a("code",[t._v("visibility")]),t._v(" 将两次重排优化成了两次重绘，但是中间由于元素本身修改导致的重排重绘将无法避免。")]),t._v(" "),a("p",[a("strong",[t._v("方式二："),a("code",[t._v("document.createDocumentFragment()")]),t._v(" 创建文档碎片：")])]),t._v(" "),a("p",[t._v("场景：现在要往一个 "),a("code",[t._v("ul#list")]),t._v(" 中插入多个 "),a("code",[t._v("li")]),t._v("。")]),t._v(" "),a("p",[t._v("如果是下面的代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySelector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#list'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fruits "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Apple'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Orange'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Banana'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Melon'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nfruits"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fruit")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" li "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'li'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    li"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fruit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("那么每一次循环都会执行一次添加 DOM 的操作，对于不支持渲染队列机制的旧浏览器，这些连续的操作将会触发四次重排（前面说过，添加 DOM 会触发重排）。")]),t._v(" "),a("p",[t._v("而文档碎片的原理是，将所有这些添加 DOM 的操作集中在文档碎片中进行，由于碎片是一棵独立于正常文档流 DOM 树的树，因此这些操作不会对原有页面产生影响，更不会导致重排。")]),t._v(" "),a("p",[t._v("具体代码如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySelector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#list'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fruits "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Apple'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Orange'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Banana'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Melon'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fragment "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createDocumentFragment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nfruits"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fruit")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" li "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'li'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  li"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fruit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  fragment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nlist"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fragment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("最后再将碎片 DOM 一次性加入到文档中即可。这样，我们将重排次数压缩至一次。")]),t._v(" "),a("p",[a("strong",[t._v("方式三：拷贝节点 => 执行操作 => 替换节点：")])]),t._v(" "),a("p",[t._v("调用 "),a("code",[t._v("cloneNode()")]),t._v(" 拷贝得到的节点独立于正常文档流的 DOM 树，对他执行的操作不会引起重排。因此我们可以先拷贝原节点得到副本，在外围对副本执行完操作之后再用它替换原节点。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" el1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cloneNode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nel2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"10px"')]),t._v("\nel1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parentNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("el2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h5",{attrs:{id:"_4-设置元素为绝对定位或固定定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-设置元素为绝对定位或固定定位"}},[t._v("#")]),t._v(" 4）设置元素为绝对定位或固定定位")]),t._v(" "),a("p",[t._v("前面说过，元素设置为绝对定位或者固定定位之后就会脱离文档流，对元素本身属性的修改虽然仍会引起重排/重绘，但这种重排/重绘只发生在自身，不会影响到正常文档流中的元素。")]),t._v(" "),a("h5",{attrs:{id:"_5-开启-gpu-硬件加速"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-开启-gpu-硬件加速"}},[t._v("#")]),t._v(" 5）开启 GPU 硬件加速")]),t._v(" "),a("blockquote",[a("p",[t._v("GPU（图像处理器） 硬件加速是指应用 GPU 的图形性能处理浏览器中的一些图形操作，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。")])]),t._v(" "),a("p",[t._v("应用了 transition 或者 animation 的元素，其所在的层将由渲染层提升为合成层，此后即使修改 opacity 或者 transform，也不会触发重排和重绘。从下图可以看出，这样的元素会跳过渲染进程主线程的布局、分层和绘制阶段，直接来到非主线程的合成阶段，由 GPU 接管渲染工作。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/12.jpg"}}),t._v(" "),a("p",[t._v("CSS3 通常依靠 transition 或者 animation 来做动画，在 GPU 硬件加速的加持下，CSS3 动画的效率比较高。当然也不是说 CSS3 动画的使用是无节制的，滥用动画意味着滥用硬件加速，还是会消耗一定内存的。")]),t._v(" "),a("p",[t._v("那么如果我们想主动开启 GPU 加速，应该怎么做呢？")]),t._v(" "),a("p",[t._v("第一种方法是使用 "),a("code",[t._v("will-change")]),t._v(" 属性：")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("will-change")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" opacity transform\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这相当于是告诉渲染引擎，接下来 "),a("code",[t._v("div")]),t._v(" 要在 "),a("code",[t._v("opacity")]),t._v(" 和 "),a("code",[t._v("transform")]),t._v("  上进行变换，这会使得 "),a("code",[t._v("div")]),t._v(" 从渲染层提升到合成层，从而在这两个属性改变时由 GPU 进行渲染，避开重排和重绘。")]),t._v(" "),a("p",[t._v("对于不支持 "),a("code",[t._v("will-change")]),t._v(" 属性的浏览器，还可以使用下面的 hack 方式开启 GPU 加速：")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("transform")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("translateZ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);