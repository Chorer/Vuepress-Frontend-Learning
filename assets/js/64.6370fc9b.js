(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{603:function(s,o,e){"use strict";e.r(o);var t=e(12),a=Object(t.a)({},(function(){var s=this,o=s.$createElement,e=s._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"对于模块化的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于模块化的理解"}},[s._v("#")]),s._v(" 对于模块化的理解")]),s._v(" "),e("p",[s._v("为什么需要模块化？")]),s._v(" "),e("ul",[e("li",[s._v("以前没有模块化的时候，都是通过 script 引入代码，存在全局变量污染、依赖管理混乱（需要手动管理）、代码可重用性差的问题，模块化可以解决这些问题")])]),s._v(" "),e("p",[s._v("模块的本质是什么？")]),s._v(" "),e("ul",[e("li",[s._v("模块本质上是一个立即执行函数表达式，通过包裹自身形成了一个封闭的函数作用域，产生隔离效果")])]),s._v(" "),e("h2",{attrs:{id:"模块化的大致发展历史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化的大致发展历史"}},[s._v("#")]),s._v(" 模块化的大致发展历史")]),s._v(" "),e("h3",{attrs:{id:"commonjs-modules-1-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-modules-1-0"}},[s._v("#")]),s._v(" CommonJS（Modules/1.0）")]),s._v(" "),e("ul",[e("li",[s._v("CommonJS 是运行时同步加载的。服务端加载的资源通常都在本地磁盘，读写速度非常快，即使采用同步加载也没事，因此 CommonJS 很适用于服务端 Nodejs。但在浏览器环境下，加载的资源通常都在远程服务器上，如果还采用 CommonJS 这种同步加载的机制，是会带来阻塞问题的。另一个导致 CommonJS 无法在浏览器中使用的原因是，它导出的变量会暴露在全局作用域中。")])]),s._v(" "),e("h3",{attrs:{id:"modules-1-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modules-1-x"}},[s._v("#")]),s._v(" Modules/1.x")]),s._v(" "),e("ul",[e("li",[s._v("针对 CommonJS 无法在浏览器端使用的问题，提出了 Modules/1.x。它致力于在浏览器端使用 CommonJS 模块，核心是分析依赖并将它们打包到一个 bundle 文件中，在浏览器端通过 script 引用。基于 Modules/1.x 的过渡产物是 browserify。")])]),s._v(" "),e("h3",{attrs:{id:"amd-modules-async"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#amd-modules-async"}},[s._v("#")]),s._v(" AMD（Modules/Async）")]),s._v(" "),e("ul",[e("li",[s._v("针对 CommonJS 无法在浏览器端使用的问题，提出了 Modules/Async，也就是 AMD 规范。它提供的是异步加载机制，并且可以使用回调函数。基于 AMD 的产物是 RequireJS")])]),s._v(" "),e("h3",{attrs:{id:"cmd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[s._v("#")]),s._v(" CMD")]),s._v(" "),e("ul",[e("li",[s._v("CMD 和 AMD 大体一致，但有两个区别。AMD 是依赖前置，提前执行，也就是说，某个模块的所有依赖必须首先声明好，而且一开始要执行一遍；而 CMD 是依赖就近，延迟执行，也就是说，某个模块的依赖可以用到的时候再声明或者执行。基于 CMD 的产物是 SeaJS。")])]),s._v(" "),e("h3",{attrs:{id:"umd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[s._v("#")]),s._v(" UMD")]),s._v(" "),e("ul",[e("li",[s._v("CommonJS 和 AMD 的结合。判断存在 define，则使用 AMD，否则判断存在 exports，则使用 CommonJS")])]),s._v(" "),e("h3",{attrs:{id:"es-module"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es-module"}},[s._v("#")]),s._v(" ES Module")]),s._v(" "),e("ul",[e("li",[s._v("官方推出的原生模块化方案，同时可以用于浏览器端和服务端")])]),s._v(" "),e("h2",{attrs:{id:"es-module-和-commonjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es-module-和-commonjs"}},[s._v("#")]),s._v(" ES Module 和 CommonJS")]),s._v(" "),e("h3",{attrs:{id:"两者的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两者的区别"}},[s._v("#")]),s._v(" 两者的区别")]),s._v(" "),e("ul",[e("li",[s._v("在 CommonJS 模块中，this 指向模块本身；在 ES Module 模块中，this 指向 undefined")]),s._v(" "),e("li",[s._v("CommonJS 一次只能导出一个对象，ES Module 可以导出多个值或对象")]),s._v(" "),e("li",[s._v("CommonJS 导出的是值的浅拷贝（模块内值的改变不会影响导出的值），ES Module 导出的是值的引用（模块内值的改变会影响导出的值）")]),s._v(" "),e("li",[s._v("CommonJS 是运行时动态导入，模块的导入情况可能是不确定的；ES Module 是编译时静态导入，模块的导入情况是确定下来的")]),s._v(" "),e("li",[s._v("CommonJS 是同步导入，因此无法在浏览器端使用；ES Module 是异步导入")])]),s._v(" "),e("h3",{attrs:{id:"es-module-如何实现类似-commonjs-的动态加载功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es-module-如何实现类似-commonjs-的动态加载功能"}},[s._v("#")]),s._v(" ES Module 如何实现类似 CommonJS 的动态加载功能")]),s._v(" "),e("ul",[e("li",[s._v("由于 ES Module 是编译时静态导入，模块是否导入以及模块路径都是确定下来的，所以天然可以进行静态分析，而 tree-shaking 其实就是基于静态分析进行的。但是，有时候我们可能需要动态加载的功能，比如条件加载（满足某个条件才导入）、按需加载（用户点击才导入）、模块动态路径等，这时候就需要借助 "),e("code",[s._v("import()")]),s._v(" 来实现了。")])])])}),[],!1,null,null,null);o.default=a.exports}}]);