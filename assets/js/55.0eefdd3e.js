(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{593:function(a,t,s){"use strict";s.r(t);var e=s(12),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("blockquote",[s("p",[a._v("总结一些 ES6 之后新的语言特性")])]),a._v(" "),s("h2",{attrs:{id:"es7-2016"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es7-2016"}},[a._v("#")]),a._v(" ES7（2016）")]),a._v(" "),s("h3",{attrs:{id:"_1-array-prototype-inlcudes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-array-prototype-inlcudes"}},[a._v("#")]),a._v(" （1）Array.prototype.inlcudes()")]),a._v(" "),s("p",[a._v("判断数组中是否包含某个元素")]),a._v(" "),s("h3",{attrs:{id:"_2-指数操作符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-指数操作符"}},[a._v("#")]),a._v(" （2）指数操作符 "),s("code",[a._v("**")])]),a._v(" "),s("p",[s("code",[a._v("2**3")]),a._v(" 等同于以前的 "),s("code",[a._v("Math.pow(2,3)")])]),a._v(" "),s("h2",{attrs:{id:"es8-2017"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es8-2017"}},[a._v("#")]),a._v(" ES8（2017）")]),a._v(" "),s("h3",{attrs:{id:"_1-async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-async-await"}},[a._v("#")]),a._v(" （1）async/await")]),a._v(" "),s("p",[a._v("新的异步编码方式")]),a._v(" "),s("h3",{attrs:{id:"_2-对象遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-对象遍历"}},[a._v("#")]),a._v(" （2）对象遍历")]),a._v(" "),s("p",[s("code",[a._v("Object.keys()")]),a._v(" 获取对象的所有 key，"),s("code",[a._v("Object.values()")]),a._v(" 获取对象的所有 value，"),s("code",[a._v("Object.entries()")]),a._v(" 获取对象的所有键值对")]),a._v(" "),s("h2",{attrs:{id:"es9-2018"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es9-2018"}},[a._v("#")]),a._v(" ES9（2018）")]),a._v(" "),s("h3",{attrs:{id:"_1-异步迭代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步迭代"}},[a._v("#")]),a._v(" （1）异步迭代")]),a._v(" "),s("p",[a._v("async/await + for...of，实现串行")]),a._v(" "),s("h3",{attrs:{id:"_2-promise-finally"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise-finally"}},[a._v("#")]),a._v(" （2）Promise.finally()")]),a._v(" "),s("p",[a._v("不管 Promise 的状态是落定为成功还是失败，都会执行 finally 里面的回调函数")]),a._v(" "),s("h3",{attrs:{id:"_3-展开运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-展开运算符"}},[a._v("#")]),a._v(" （3）展开运算符")]),a._v(" "),s("p",[s("code",[a._v("...")]),a._v(" 用于合并或者展开对象和数组")]),a._v(" "),s("h2",{attrs:{id:"es10-2019"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es10-2019"}},[a._v("#")]),a._v(" ES10（2019）")]),a._v(" "),s("h3",{attrs:{id:"_1-flat-和-flatmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-flat-和-flatmap"}},[a._v("#")]),a._v(" （1）flat 和 flatMap")]),a._v(" "),s("p",[a._v("flat 对数组进行扁平化，flatMap 对数组进行扁平化之后再 map 映射")]),a._v(" "),s("h3",{attrs:{id:"_2-trimstart-和-trimend"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-trimstart-和-trimend"}},[a._v("#")]),a._v(" （2）trimStart 和 trimEnd")]),a._v(" "),s("p",[a._v("去除字符串前面或者后面的空格")]),a._v(" "),s("h2",{attrs:{id:"es11-2020"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es11-2020"}},[a._v("#")]),a._v(" ES11（2020）")]),a._v(" "),s("h3",{attrs:{id:"_1-空值合并运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-空值合并运算符"}},[a._v("#")]),a._v(" （1）空值合并运算符")]),a._v(" "),s("p",[a._v("逻辑或 "),s("code",[a._v("||")]),a._v(" 的规则是，如果左操作数是假值，则返回右操作数；而空值合并运算符 "),s("code",[a._v("??")]),a._v(" 的规则是，如果左操作数是 null 或者 undefined，则返回右操作数。")]),a._v(" "),s("p",[a._v("这个区别很重要。为什么呢？看下面的例子：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("123")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// b 最后是 123")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("??")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("123")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// c 最后是 0 ")]),a._v("\n")])])]),s("p",[a._v("我们期望的结果其实是，如果 a 是一个有效值，即使它是 0，也要让 b 等于 a。但使用 "),s("code",[a._v("||")]),a._v(" 的时候，0 会被解析为假值，导致 b 最终等于 123；而如果使用 "),s("code",[a._v("??")]),a._v("，则不存在这个问题，因为 0 不是 null 或者 undefined，所以 c 最终可以等于 0。")]),a._v(" "),s("h3",{attrs:{id:"_2-可选链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-可选链"}},[a._v("#")]),a._v(" （2）可选链")]),a._v(" "),s("p",[a._v("可选链 "),s("code",[a._v("?.")]),a._v(" 可以检测不确定的中间节点：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// obj.a 是 undefined，无法读取它的 b 属性，这里会报错")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?.")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?.")]),a._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 不会报错")]),a._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?.")]),a._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 不会报错         ")]),a._v("\n")])])]),s("h3",{attrs:{id:"_3-promise-allsettled"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise-allsettled"}},[a._v("#")]),a._v(" （3）Promise.allSettled()")]),a._v(" "),s("p",[a._v("Promise.all 只有所有的 Promise 状态都落定为成功，才会返回一个结果数组；而 Promise.allSettled 则不管 Promise 的状态是落定为成功还是失败，都会被记录在返回的数组中")]),a._v(" "),s("h3",{attrs:{id:"_4-bigint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-bigint"}},[a._v("#")]),a._v(" （4）BigInt")]),a._v(" "),s("p",[a._v("新的 JS 基本数据类型。在以前，JS 能够表示的最大整数是 "),s("code",[a._v("2^53-1")]),a._v("，一旦大于这个数，那么精度就会丢失，导致出现 "),s("code",[a._v("2^53 === 2^53+1")]),a._v(" 这种情况。ES10 引入了 BigInt，它可以表示任意大的整数，通过 "),s("code",[a._v("123n")]),a._v(" 或者 "),s("code",[a._v("BigInt(123)")]),a._v(" 可以创建一个 BigInt。")]),a._v(" "),s("h3",{attrs:{id:"_5-import"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-import"}},[a._v("#")]),a._v(" （5）import()")]),a._v(" "),s("p",[a._v("提供动态导入、按需导入的功能")]),a._v(" "),s("h2",{attrs:{id:"es12-2021"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es12-2021"}},[a._v("#")]),a._v(" ES12（2021）")]),a._v(" "),s("h3",{attrs:{id:"_1-replaceall"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-replaceall"}},[a._v("#")]),a._v(" （1）replaceAll")]),a._v(" "),s("p",[a._v("符合规则的所有字符都会被替换掉")]),a._v(" "),s("h3",{attrs:{id:"_2-promsie-any"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-promsie-any"}},[a._v("#")]),a._v(" （2）Promsie.any")]),a._v(" "),s("p",[a._v("Promise.any 和 Promise.all 是相反的。Promise.all 只要有一个失败，就返回失败的 promise，而 Promise.any 只要有一个成功，就返回成功的 promise")]),a._v(" "),s("h3",{attrs:{id:"_3-weakref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-weakref"}},[a._v("#")]),a._v(" （3）WeakRef")]),a._v(" "),s("p",[a._v("在以前，WeakMap 中的对象使用的是弱引用，而 WeakRef 提供了一个更加直接的方式去创建弱引用")]),a._v(" "),s("h3",{attrs:{id:"_4-数字分隔符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-数字分隔符"}},[a._v("#")]),a._v(" （4）数字分隔符")]),a._v(" "),s("p",[a._v("允许给数字字面量使用下划线作为分隔符，从而加强可读性：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1_000_000_000")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000000000")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);