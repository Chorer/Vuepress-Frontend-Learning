(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{552:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("blockquote",[a("p",[t._v("手动回收和自动回收")])]),t._v(" "),a("p",[t._v("有些数据使用完之后就不再需要了，变成了垃圾数据。垃圾数据如果不及时回收，释放其占用的内存空间，就会引起内存泄露问题。")]),t._v(" "),a("p",[t._v("C/C++ 采用的是手动回收，开发者需要自己编写代码手动进行内存的分配和释放；JS/Java/Python 等采用的是自动回收，会有专门的垃圾回收机制自动进行垃圾回收。以 JS 为例，它的垃圾回收机制是通过浏览器的 JS 引擎（比如 Chrome 的 V8）实现的，回收的垃圾包括栈数据和堆数据。")]),t._v(" "),a("h2",{attrs:{id:"栈数据回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈数据回收"}},[t._v("#")]),t._v(" 栈数据回收")]),t._v(" "),a("p",[t._v("以下面这段代码为例：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("执行到 "),a("code",[t._v("var d = {name: 4}")]),t._v(" 的时候，执行上下文栈/调用栈是：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("foo")]),t._v("函数执行上下文")]),t._v(" "),a("li",[a("code",[t._v("bar")]),t._v(" 函数执行上下文")]),t._v(" "),a("li",[t._v("全局执行上下文")])]),t._v(" "),a("p",[t._v("并且会有一个 ESP 指针指向当前激活的执行上下文，即 "),a("code",[t._v("foo")]),t._v(" 函数执行上下文。当 "),a("code",[t._v("foo")]),t._v(" 执行完毕的时候，我们会说“"),a("code",[t._v("foo")]),t._v(" 的执行上下文从调用栈中弹出，并销毁”，实际上是指针 ESP 下移到 "),a("code",[t._v("bar")]),t._v(" 函数执行上下文。"),a("code",[t._v("foo")]),t._v(" 函数执行上下文严格意义上来说并没有销毁，还存在栈空间中，但已经属于无效内存了，因为如果这时候调用了另一个函数，那么那个函数的执行上下文随时可以使用 "),a("code",[t._v("foo")]),t._v(" 腾出的这块栈空间。")]),t._v(" "),a("blockquote",[a("p",[t._v("指针下移后，"),a("code",[t._v("foo")]),t._v(" 函数执行上下文销毁，相关的栈数据（通常是基本类型数据）也会被回收")])]),t._v(" "),a("h2",{attrs:{id:"堆数据回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆数据回收"}},[t._v("#")]),t._v(" 堆数据回收")]),t._v(" "),a("p",[t._v("当 "),a("code",[t._v("foo")]),t._v(" 和 "),a("code",[t._v("bar")]),t._v(" 执行完毕之后，相关的栈数据就会被回收，包括 "),a("code",[t._v("a")]),t._v(" 和 "),a("code",[t._v("c")]),t._v(" 这样的基本类型数据，也包括 "),a("code",[t._v("b")]),t._v(" 和 "),a("code",[t._v("d")]),t._v(" 这样的引用类型数据（因为它们实际上存放的是对象的地址）。但是堆内存中的数据（"),a("code",[t._v("{name: 2}")]),t._v(" 和 "),a("code",[t._v("{name: 4}")]),t._v(" 对象）还在，V8 的垃圾回收器主要就是用来回收堆内存中的数据。")]),t._v(" "),a("blockquote",[a("p",[t._v("堆内存的数据既包括引用类型数据，也包括闭包数据")])]),t._v(" "),a("h3",{attrs:{id:"堆的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆的结构"}},[t._v("#")]),t._v(" 堆的结构")]),t._v(" "),a("p",[t._v("V8 引擎将堆分为两个区域，一个是"),a("strong",[t._v("新生代区域")]),t._v("（new space），比较小，存放小且存活时间短的对象；一个是"),a("strong",[t._v("老生代区域")]),t._v("（old space），比较大，存放大且存活时间长的对象。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/13.jpg"}}),t._v(" "),a("h3",{attrs:{id:"垃圾回收器的工作机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作机制"}},[t._v("#")]),t._v(" 垃圾回收器的工作机制")]),t._v(" "),a("p",[t._v("V8 引擎有两种垃圾回收器，一种是回收新生代垃圾的副垃圾回收器，一种是回收老生代垃圾的主垃圾回收器。不管是哪种垃圾回收器，垃圾回收大体都要经过如下三个步骤：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("标记")]),t._v("：将对象标记为两类，一类是活动对象（live object），也即还在使用的对象；一类是非活动对象（dead object），也即需要被回收的对象。")]),t._v(" "),a("li",[a("strong",[t._v("回收")]),t._v("：回收上一步标记的所有非活动对象")]),t._v(" "),a("li",[a("strong",[t._v("整理")]),t._v("：如果频繁回收对象，可能会产生大量非连续的内存空间（即内存碎片）。而内存空间的分配必须是连续的，这就会导致某些较大的对象无法被分配内存。所以对于这些内存碎片要进行整理以腾出有效的内存空间。不过这一步并不是必须的，比如新生代区域的垃圾回收就不需要进行整理。")])]),t._v(" "),a("h4",{attrs:{id:"副垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[t._v("#")]),t._v(" 副垃圾回收器")]),t._v(" "),a("p",[t._v("副垃圾回收器负责回收新生代垃圾，它采用的是 "),a("strong",[t._v("Scavenge 算法")]),t._v("。这种算法会把新生代区域对半划分为两个区域：对象区域和空闲区域。")]),t._v(" "),a("p",[t._v("每次有新的对象都往对象区域里放，一旦对象区域满了，就触发一次垃圾回收。首先是标记出非活动对象和活动对象，接着把活动对象复制到空闲区域中，同时进行一次有序的排列，这避免了空闲区域中出现内存碎片，因此也就避免了后续的整理操作。最后两极反转，两个区域互换。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/14.jpg"}}),t._v(" "),a("blockquote",[a("p",[t._v("为什么新生代区域设置得比较小？")])]),t._v(" "),a("p",[t._v("因为新生代区域采用的是 Scavenge 算法，需要对活动对象进行复制，如果新生代区域太大，那么可容纳的对象就会很多，单个对象也可能很大，这会影响复制的执行效率。")]),t._v(" "),a("p",[t._v("但也正因为新生代区域比较小，所以区域很快就会被活动对象填满。对此，V8 采用了一种"),a("strong",[t._v("对象晋升策略")]),t._v("，经过两次垃圾回收还存活的对象，会转送到老生代区域。")]),t._v(" "),a("h4",{attrs:{id:"主垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[t._v("#")]),t._v(" 主垃圾回收器")]),t._v(" "),a("p",[t._v("主垃圾回收器负责回收老生代垃圾。因为老生代区域中一般存放的都是比较大的对象，若还采用 Scavenge 算法，那么复制对象的操作将会非常耗时，所以它采用的是"),a("strong",[t._v("标记-清除算法")]),t._v("。具体步骤如下：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("标记：遍历整个调用栈，标记出老生代对象中的所有活动对象，未标记的认定为非活动对象。")]),t._v(" "),a("p",[t._v("以这段代码为例：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" d "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("当执行到 "),a("code",[t._v("var b = {name: 2}")]),t._v(" 的时候，"),a("code",[t._v("foo")]),t._v(" 函数执行上下文还在，因此遍历调用栈的时候，存在着变量 "),a("code",[t._v("b")]),t._v(" 保存着堆空间中 "),a("code",[t._v("{name: 2}")]),t._v(" 对象的地址，据此将 "),a("code",[t._v("{name: 2}")]),t._v(" 标记为活动对象。")]),t._v(" "),a("p",[t._v("而 "),a("code",[t._v("bar")]),t._v(" 函数执行上下文肯定已经销毁，因此遍历调用栈的时候，不存在着一个变量保存着堆空间中 "),a("code",[t._v("{name: 4}")]),t._v(" 对象的地址， "),a("code",[t._v("{name: 4}")]),t._v(" 会被认定为非活动对象。")])]),t._v(" "),a("li",[a("p",[t._v("回收：这个阶段会直接回收之前找到的非活动对象。由于是直接回收，所以容易产生内存碎片，导致后续较大的对象很难被分配内存空间。因此有一种改进的"),a("strong",[t._v("标记-整理算法")]),t._v("，它会先把所有活动对象挪到一端，然后直接回收这一端外围的所有内存，这样就可以确保这一端的外围都是可用的、连续的内存空间。")])])]),t._v(" "),a("p",[t._v("​\t\t"),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/15.jpg"}})]),t._v(" "),a("h4",{attrs:{id:"全停顿和增量标记算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全停顿和增量标记算法"}},[t._v("#")]),t._v(" 全停顿和增量标记算法")]),t._v(" "),a("p",[t._v("JS 的执行和垃圾回收都要在主线程上进行，由于 JS 是单线程的，所以垃圾回收会阻塞 JS 的执行。全停顿指的是：暂停 JS 执行 => 进行垃圾回收（标记、回收、整理）=> 恢复 JS 执行。如果是新生代垃圾回收，问题还不大，因为新生代区域本身空间和存放的对象就很少，但如果是老生代垃圾回收，那么用户可能就会很明显地感知到中断 JS 执行带来的影响（比如某个动画中断了 200 ms，这种卡顿是比较明显的）")]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/16.jpg"}}),t._v(" "),a("p",[t._v("所以对应地出现了增量标记算法：")]),t._v(" "),a("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/17.jpg"}}),t._v(" "),a("p",[t._v("增量标记算法将一个完整的标记过程拆分为多个子标记过程，并与 JS 的执行交替进行，直到整个标记过程结束为止。由于每个子标记过程非常短，所以用户对于 JS 执行的中断几乎是无感知的。")]),t._v(" "),a("h4",{attrs:{id:"被淘汰的算法-引用计数算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被淘汰的算法-引用计数算法"}},[t._v("#")]),t._v(" 被淘汰的算法：引用计数算法")]),t._v(" "),a("p",[t._v("和标记-清除算法一起并列的还有引用计数算法，但已经被现代浏览器淘汰。")]),t._v(" "),a("p",[t._v("引用计数算法的核心是跟踪记录每个对象被引用的次数，当有一个新的变量引用这个对象的时候，次数就加一，反之则减一。当引用次数降为 0 的时候，说明对象已经不可达，此时就可以回收它占用的内存。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Jack'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 次数：1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 次数：2")]),t._v("\nobj1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'John'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 次数：1")]),t._v("\nobj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("                "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 次数：0")]),t._v("\n")])])]),a("p",[t._v("需要注意的是，如果对象中包含对象，那么在内部对象的引用次数降为 0 之前，外部对象无法被回收（即使本身引用次数已经降为 0）。比如：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    info"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tage"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" info "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("info\nobj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// obj 引用次数变为 0，但不会被回收，因为 obj.info 的引用次数不为 0")]),t._v("\ninfo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// obj.info 引用次数变为 0，因此 obj 会被回收")]),t._v("\n")])])]),a("p",[t._v("引用计数算法最大的问题是循环引用。以这个函数为例：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    obj1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("friend "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj2\n    obj2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("friend "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" obj1\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("obj1")]),t._v(" 和 "),a("code",[t._v("obj2")]),t._v(" 互相引用着对方，导致即使函数执行完毕，两个对象的引用次数也无法降至 0，因此它们的内存都无法被回收。如果函数被调用多次，就会发生大规模的内存泄露。")]),t._v(" "),a("p",[t._v("但是，如果采用的是标记-清除算法，就没有这个问题了 —— 函数执行完毕，对应的执行上下文就会从调用栈弹出并销毁，栈空间中保存着对象地址的 "),a("code",[t._v("obj1")]),t._v(" 和 "),a("code",[t._v("obj2")]),t._v(" 变量也会销毁。主垃圾回收器在递归遍历调用栈的时候，发现调用栈中并不存在着任何一个变量保存着堆空间中 "),a("code",[t._v("{age: 12}")]),t._v(" 和 "),a("code",[t._v("{age: 24}")]),t._v(" 对象的地址，于是认定两个对象属于非活动对象，就会回收它们的内存。")]),t._v(" "),a("h2",{attrs:{id:"内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露"}},[t._v("#")]),t._v(" 内存泄露")]),t._v(" "),a("h3",{attrs:{id:"_1-场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-场景"}},[t._v("#")]),t._v(" 1）场景")]),t._v(" "),a("p",[t._v("以下是一些常见的可能引起内存泄露的编码场景。")]),t._v(" "),a("p",[a("strong",[t._v("意外的全局变量")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("globalVariable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("globalVariable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("调用函数的时候 "),a("code",[t._v("this")]),t._v(" 指向全局对象，因此创建了全局变量 "),a("code",[t._v("bar")]),t._v("；"),a("code",[t._v("foo")]),t._v(" 没有显式声明，因此也是一个全局变量。全局变量一般生存周期很长，且不会被当成垃圾回收，因此这些意外创建的全局变量会导致内存泄露。")]),t._v(" "),a("p",[t._v("除了编码中尽量避免之外，也可以手动清除：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo\n")])])]),a("p",[a("strong",[t._v("未清除的定时器")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" someResource "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Node'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someResource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("定时器没有及时 clear，导致回调函数不会被回收，内部依赖的变量（node 和 someResource）也不会被回收")]),t._v(" "),a("p",[a("strong",[t._v("对 DOM 节点的引用")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ele "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'box'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ele"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("尽管显式地移除了 DOM 节点，但由于变量 "),a("code",[t._v("ele")]),t._v(" 还保存着对于该节点的引用，所以它实际上还占用着内存，并没有被回收。需要通过 "),a("code",[t._v("ele = null")]),t._v(" 手动释放引用。")]),t._v(" "),a("p",[a("strong",[t._v("闭包内的自由变量")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createClosure")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" closure "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createClosure")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[a("code",[t._v("a")]),t._v(" 属于被 closure 闭包函数引用的闭包变量，因此不会销毁。"),a("strong",[t._v("注意")]),t._v("，不是说闭包函数本身不销毁，而是说闭包函数内使用的那个自由变量不销毁")]),t._v(" "),a("blockquote",[a("p",[t._v("闭包是否真的会导致内存泄漏？")])]),t._v(" "),a("p",[t._v("引用 hax 大佬的原话：闭包导致内存泄漏只是以前 IE 浏览器的一个 bug，现代浏览器是不存在这个问题的，因此可以认为闭包不会导致内存泄漏。")]),t._v(" "),a("h3",{attrs:{id:"_2-如何检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何检测"}},[t._v("#")]),t._v(" 2）如何检测")]),t._v(" "),a("p",[t._v("既然知道了哪些场景可能会引起内存泄漏，那么在编码上就可以多加注意。但是，如何检测是否真的发生了内存泄漏呢？单靠查看代码显然是不现实的。")]),t._v(" "),a("p",[a("strong",[t._v("Chrome 自带的任务管理器")])]),t._v(" "),a("p",[t._v("Chrome 自带了一个任务管理器，可以看到每个进程的内存使用情况以及 JS 使用内存情况，如果页面稳定后，JS 使用内存情况仍然有上涨的趋势，则可能存在内存泄漏")]),t._v(" "),a("p",[a("strong",[t._v("Performance 面板")])]),t._v(" "),a("p",[t._v("打开开发者工具的 Performance 面板，先手动触发垃圾回收，再点击录制，中间再进行垃圾回收，然后结束录制。之后观察曲线图，如果 JS heap 有较大的波动，则可能存在内存泄漏")]),t._v(" "),a("p",[a("strong",[t._v("堆快照")])]),t._v(" "),a("p",[t._v("打开开发者工具的 Memory 面板，选择 Heap Snapshot，之后进行录制，也可以分析内存泄漏。")])])}),[],!1,null,null,null);s.default=e.exports}}]);