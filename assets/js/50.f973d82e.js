(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{588:function(t,s,a){"use strict";a.r(s);var e=a(12),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"相等性判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相等性判断"}},[t._v("#")]),t._v(" 相等性判断")]),t._v(" "),a("h3",{attrs:{id:"_1-和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-和"}},[t._v("#")]),t._v(" 1）"),a("code",[t._v("==")]),t._v(" 和 "),a("code",[t._v("!=")])]),t._v(" "),a("ul",[a("li",[t._v("两个字符串比较时，按位比较字符的 unicode")]),t._v(" "),a("li",[t._v("两个对象比较时，不会拆箱，只会比较是否引用了同一个对象")]),t._v(" "),a("li",[t._v("其他情况下，比较时通常会发生隐式类型转换，并且尽量转型为一个数字")]),t._v(" "),a("li",[a("code",[t._v("null")]),t._v(" 和 "),a("code",[t._v("undefined")]),t._v(" 在和其他值比较时，不会发生类型转换。"),a("strong",[t._v("注意")]),t._v("，"),a("code",[t._v("null == 0")]),t._v(" 和 "),a("code",[t._v("undefined == 0")]),t._v(" 都返回 false（尽管 null 可以转型为 0，undefined 可以转型为 NaN）。")]),t._v(" "),a("li",[a("code",[t._v("null == undefined")]),t._v("  返回 true")])]),t._v(" "),a("h3",{attrs:{id:"_2-和"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-和"}},[t._v("#")]),t._v(" 2）"),a("code",[t._v("===")]),t._v(" 和 "),a("code",[t._v("!==")])]),t._v(" "),a("ul",[a("li",[t._v("比较的时候不会发生隐式类型转换")])]),t._v(" "),a("h3",{attrs:{id:"_3-object-is"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-object-is"}},[t._v("#")]),t._v(" 3）"),a("code",[t._v("Object.is()")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("比较的时候不会发生隐式类型转换")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Object.is()")]),t._v(" 比 "),a("code",[t._v("===")]),t._v(" 优越的地方在于，它可以区分 "),a("code",[t._v("±0")]),t._v("；但比 "),a("code",[t._v("===")]),t._v(" 不足的地方在于，它无法区分 "),a("code",[t._v("NaN")]),t._v("。所以，不能说 "),a("code",[t._v("Object.is()")]),t._v(" 比 "),a("code",[t._v("===")]),t._v(" 更加严格。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Object.is 可以区分 ±0")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("is")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是不能区分 NaN（实际上，两个 NaN 通常都认为是不可能相等的，因为 NaN 有很多种情况）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\nObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("is")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])])])]),t._v(" "),a("h2",{attrs:{id:"相等性判断的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相等性判断的算法"}},[t._v("#")]),t._v(" 相等性判断的算法")]),t._v(" "),a("p",[t._v("相等性判断的算法有四种：")]),t._v(" "),a("ul",[a("li",[t._v("非严格相等："),a("code",[t._v("==")])]),t._v(" "),a("li",[t._v("严格相等： "),a("code",[t._v("===")])]),t._v(" "),a("li",[t._v("同值相等："),a("code",[t._v("Object.is()")])]),t._v(" "),a("li",[t._v("零值相等： 和同值相等一样，但是认为 "),a("code",[t._v("±0")]),t._v(" 相等。set 和 map 采用的就是零值相等算法，因此它们不能区分 "),a("code",[t._v("±0")]),t._v(" 和 "),a("code",[t._v("NaN")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"大小比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大小比较"}},[t._v("#")]),t._v(" 大小比较")]),t._v(" "),a("ul",[a("li",[t._v("两个字符串比较时，按位比较字符的 unicode")]),t._v(" "),a("li",[t._v("两个对象比较时，先拆箱，再比较")]),t._v(" "),a("li",[t._v("其它情况下，比较时通常会发生隐式类型转换，并且尽量转型为一个数字")])])])}),[],!1,null,null,null);s.default=n.exports}}]);